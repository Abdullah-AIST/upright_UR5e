include:
  -
    package: upright_cmd
    path: config/arrangements.yaml
  -
    key: obstacles
    package: upright_cmd
    path: config/controller/obstacles/dynamic.yaml

# compute a new control policy every `control_period` seconds
timestep: 0.025
use_noisy_state_to_plan: true
gravity: [0, 0, -9.81]
solver_method: SQP  # SQP or DDP

balancing:
  arrangement: nothing
  constraint_type: soft
  enabled: true
  use_force_constraints: false
  use_bounded_constraints: true
  enable_normal_constraint: true
  enable_friction_constraint: true
  enable_zmp_constraint: true

  force_weight: 0.001

  mu: 1e-3
  delta: 1e-3

inertial_alignment:
  enabled: false
  use_angular_acceleration: false
  weight: 10

# needs to be implemented for each particular system
tracking:
  rate: 125
  Kp: null

# desired waypoints are set relative to the initial EE pose
# each waypoint consists of:
#   millis: time from beginning of trajectory in milliseconds
#   position: [x, y, z] end effector position
#   orientation: [x, y, z, w] end effector orientation quaternion
# waypoints:
#   -
#     millis: 0
#     position: [2.0, 0.0, 0.0]
#     orientation: [0.0, 0.0, 0.0, 1.0]

obstacles:
  enabled: false
  constraint_type: hard

  # extra margin between objects
  # Important: this needs to be > 0 for the resulting constraint to be
  # differentiable
  minimum_distance: 0.1

  # relaxed barrier function parameters
  mu: 1e-2
  delta: 1e-3

infofile:
  package: "upright_control"
  path: "config/mpc/task.info"

# TODO: ideally would be able to extend other objects for easy experimentation
objects:
  # EE is a special object
  ee:
    shape:
      type: cuboid
      side_lengths: [0.23, 0.3, 0.064]
    position: [0.1, 0.13, -0.032]  # box centroid relative to r_ew_w

  cube:
    mass:
      min: 1.0
      max: 1.0
    com:
      height: 0.025
      half_lengths: [0.0, 0.0, 0.0]
    radii_of_gyration:
      use_exact:
        shape: cuboid
        side_lengths: [0.1, 0.1, 0.05]
    mu_min: 0.5
    support_area:
      shape: "rect"
      lx: 0.1
      ly: 0.1
    height: 0.05

  bottle:
    mass:
      min: 0.5
      max: 0.5
    com:
      height: 0.075
      half_lengths: [0, 0, 0]  # these are for the uncertainty
    radii_of_gyration:
      use_exact:
        shape: cuboid
        side_lengths: [0.065, 0.065, 0.15]
    mu_min: 0.15
    support_area:
      shape: rect
      lx: 0.065
      ly: 0.065
    height: 0.15

  # foam_die_old:
  #   mass:
  #     min: 0.02
  #     max: 0.02
  #   com:
  #     height: 0.0325
  #     half_lengths: [0, 0, 0]  # these are for the uncertainty
  #   radii_of_gyration:
  #     use_exact:
  #       shape: cuboid
  #       side_lengths: [0.065, 0.065, 0.065]
  #   mu_min: 0.4
  #   support_area:
  #     shape: rect
  #     lx: 0.05
  #     ly: 0.05
  #   height: 0.065

  # wood_block_old:
  #   mass:
  #     min: 0.18
  #     max: 0.18
  #   com:
  #     height: 0.019
  #     half_lengths: [0, 0, 0]
  #   radii_of_gyration:
  #     use_exact:
  #       shape: cuboid
  #       side_lengths: [0.103, 0.09, 0.038]
  #   mu_min: 0.27
  #   support_area:
  #     shape: rect
  #     lx: 0.103
  #     ly: 0.09
  #   height: 0.038

  wood_block:
    mass: 0.18
    com_offset: [0, 0, 0]  # relative to centroid of shape
    shape:
      type: cuboid
      side_lengths: [0.103, 0.09, 0.038]
    support_area_inset: 0.0
    # for now we assume inertia is exact, but we should use parallel axis
    # theorem to account for com_offset

  # TODO: do we want inset a property of the object class or the particular
  # instance in an arrangement?
  foam_die:
    mass: 0.02
    com_offset: [0, 0, 0]
    shape:
      type: cuboid
      side_lengths: [0.065, 0.065, 0.065]
    support_area_inset: 0.0
